$date
	Wed Jul  2 23:00:22 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module top_sum_res_tb $end
$var wire 4 ! an [3:0] $end
$var wire 7 " SSeg [0:6] $end
$var reg 4 # A [3:0] $end
$var reg 4 $ B [3:0] $end
$var reg 1 % Sel $end
$var reg 1 & clk $end
$var reg 1 ' rst $end
$scope module TSR $end
$var wire 4 ( A [3:0] $end
$var wire 4 ) B [3:0] $end
$var wire 1 % Sel $end
$var wire 1 & clk $end
$var wire 1 ' rst $end
$var wire 5 * inp_top [4:0] $end
$var wire 4 + an [3:0] $end
$var wire 7 , SSeg [0:6] $end
$var wire 4 - S [3:0] $end
$var wire 1 . Cout $end
$scope module sr $end
$var wire 4 / A [3:0] $end
$var wire 4 0 B [3:0] $end
$var wire 4 1 B_c [3:0] $end
$var wire 1 % Sel $end
$var wire 4 2 S [3:0] $end
$var wire 1 . Cout $end
$scope module UUT $end
$var wire 4 3 A [3:0] $end
$var wire 4 4 B [3:0] $end
$var wire 1 % Ci $end
$var wire 1 5 c2 $end
$var wire 1 6 c1 $end
$var wire 1 7 c0 $end
$var wire 4 8 S [3:0] $end
$var wire 1 . Cout $end
$scope module S0 $end
$var wire 1 9 A $end
$var wire 1 : B $end
$var wire 1 % Ci $end
$var wire 1 7 Cout $end
$var wire 1 ; S $end
$var wire 1 < a_ab $end
$var wire 1 = cout_t $end
$var wire 1 > x_ab $end
$upscope $end
$scope module S1 $end
$var wire 1 ? A $end
$var wire 1 @ B $end
$var wire 1 7 Ci $end
$var wire 1 6 Cout $end
$var wire 1 A S $end
$var wire 1 B a_ab $end
$var wire 1 C cout_t $end
$var wire 1 D x_ab $end
$upscope $end
$scope module S2 $end
$var wire 1 E A $end
$var wire 1 F B $end
$var wire 1 6 Ci $end
$var wire 1 5 Cout $end
$var wire 1 G S $end
$var wire 1 H a_ab $end
$var wire 1 I cout_t $end
$var wire 1 J x_ab $end
$upscope $end
$scope module S3 $end
$var wire 1 K A $end
$var wire 1 L B $end
$var wire 1 5 Ci $end
$var wire 1 . Cout $end
$var wire 1 M S $end
$var wire 1 N a_ab $end
$var wire 1 O cout_t $end
$var wire 1 P x_ab $end
$upscope $end
$upscope $end
$upscope $end
$scope module u_top $end
$var wire 1 & clk $end
$var wire 5 Q inp [4:0] $end
$var wire 1 ' rst $end
$var wire 1 R fdivider $end
$var wire 4 S c [3:0] $end
$var wire 4 T bcdsseg [3:0] $end
$var wire 4 U an [3:0] $end
$var wire 7 V SSeg [0:6] $end
$scope module BCD $end
$var wire 5 W inp [4:0] $end
$var wire 1 ' rst $end
$var wire 1 R clk2 $end
$var reg 1 X algo $end
$var reg 4 Y bcd [3:0] $end
$var reg 4 Z c [3:0] $end
$upscope $end
$scope module BCDtoSSeg $end
$var wire 4 [ BCD [3:0] $end
$var wire 4 \ an [3:0] $end
$var wire 4 ] c [3:0] $end
$var reg 7 ^ SSeg [0:6] $end
$upscope $end
$scope module fdiv $end
$var wire 1 & clk $end
$var reg 24 _ counter [23:0] $end
$var reg 1 R fdiv $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 _
bx ^
b0 ]
b0 \
bx [
b0 Z
bx Y
0X
b0 W
bx V
b0 U
bx T
b0 S
0R
b0 Q
0P
0O
0N
0M
0L
0K
0J
0I
0H
0G
0F
0E
0D
0C
0B
0A
0@
0?
0>
0=
0<
0;
0:
09
b0 8
07
06
05
b0 4
b0 3
b0 2
b0 1
b0 0
b0 /
0.
b0 -
bx ,
b0 +
b0 *
b0 )
b0 (
1'
0&
0%
b0 $
b0 #
bx "
b0 !
$end
#5000
b1 _
1&
#10000
1G
16
1B
1;
b101 *
b101 Q
b101 W
b101 -
b101 2
b101 8
0A
1@
1>
0D
b10 1
b10 4
19
1?
0&
b10 $
b10 )
b10 0
b11 #
b11 (
b11 /
b11 3
0'
#15000
b10 _
1&
#20000
0&
#25000
b11 _
1&
#30000
1.
1O
15
1C
1I
0G
0M
1<
0>
0B
1D
1J
1P
0A
1:
0@
1F
1L
17
b1101 1
b1101 4
b10001 *
b10001 Q
b10001 W
b1 -
b1 2
b1 8
1;
0=
0&
1%
#35000
b100 _
1&
#40000
0&
#45000
b101 _
1&
#50000
0.
1M
0O
05
1G
0I
06
1A
0C
07
0=
b1111 *
b1111 Q
b1111 W
b1111 -
b1111 2
b1111 8
1;
0:
0<
0>
b1100 1
b1100 4
09
0&
b11 $
b11 )
b11 0
b10 #
b10 (
b10 /
b10 3
#55000
b110 _
1&
#60000
0&
#65000
b111 _
1&
#70000
0G
0J
0A
1.
0M
0F
0D
1N
0P
b10000 *
b10000 Q
b10000 W
b0 -
b0 2
b0 8
0;
b1000 1
b1000 4
0?
1K
0&
0%
b1000 $
b1000 )
b1000 0
b1000 #
b1000 (
b1000 /
b1000 3
#75000
b1000 _
1&
#80000
0&
#85000
b1001 _
1&
#90000
0&
#95000
b1010 _
1&
